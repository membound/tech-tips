# Бази даних

## Пріоритети SQL-виразів

| Пріорітет | Вираз    | Функція                                       |
| --------- | -------- | --------------------------------------------- |
| 1         | FROM     | Обирає і з'єднує таблиці для отримання данних |
| 2         | WHERE    | Фільтрує дані                                 |
| 3         | GROUP BY | Агрегує дані                                  |
| 4         | HAVING   | Фільтрує агреговані дані                      |
| 5         | SELECT   | Повертає фінальний результат                  |
| 6         | ORDER BY | Сортує дані                                   |
| 7         | LIMIT    | Обмежує кількість результуючих рядків         |

## ACID

*Властивості, що гарантують надійну обробку транзакцій:*

1. **Атомарність**: транзакція або повністю успішна, або повністю не вдається.
2. **Узгодженість**: система знаходиться в узгодженому стані на початку та завершенні транзакції.  
   *Неузгодженість посеред виконання невидима завдяки ізоляції та атомарності.*
3. **Ізоляція**: одночасні транзакції залишають БД у стані, ніби вони виконувалися послідовно.
4. **Довговічність**: результати транзакцій зберігаються, навіть при збої системи.

|                 | Втрачені зміни | Брудне читання | Неповторюване читання | Фантомне читання | Інші аномалії |
| --------------- | :------------: | :------------: | :-------------------: | :--------------: | :-----------: |
| Read Uncommited |       -        |      так       |          так          |       так        |      так      |
| Read Commited   |       -        |       -        |          так          |       так        |      так      |
| Repeatable Read |       -        |       -        |           -           |       так        |      так      |
| Serializable    |       -        |       -        |           -           |        -         |       -       |

## Агрегатні функції

`MIN()`, `MAX()`, `AVG()`, `COUNT()`, `SUM()`

## Нормалізація БД

- **1NF**: кожна комірка таблиці містить одне значення, а кожен рядок є унікальним.
- **2NF**: таблиця повинна мати ключ, а всі стовпці повинні залежати від повного ключа.
- **3NF**: необхідно видалити стовпці, які не залежать (навіть транзитивно) від первинного ключа.
- **BCNF**: прибирає повторення значень у разі зіставного ключа (частина ключа не повинна залежати від неключового стовпця).  
 **Наприклад:** *проект і користувачі зберігаються в одній таблиці, можуть виникати дублікати проекту, якщо користувачів багато.*

- **4NF**: таблиця, що знаходиться у 3NF, і для кожної нетривіальної багатозначної залежності $X \rightarrow  Y$ виконується, що $X$ є суперключем.  
  *(Наприклад, (id, курс, викладач, книга) потрібно розбити на окремі таблиці, щоб уникнути дублювання.)*
- **5NF**: розбиття таблиці на менші підгрупи, які можна відновити за допомогою JOIN.
- **6NF**: декомпозиція до кінця, використовується в хронологічних БД.

## Види SQL JOIN

|                                                   | Тип JOIN                             | Опис                                       |
| ------------------------------------------------- | ------------------------------------ | ------------------------------------------ |
| ![](/media/inner-join-vis.png)              | **INNER JOIN**                       | Внутрішнє з'єднання                        |
| ![](/media/left-join-vis.png)               | **LEFT JOIN**                        | Ліве з'єднання                             |
| ![](/media/left-without-right-join-vis.png) | **LEFT JOIN ⊄ RIGHT**                | Ліве з'єднання, що не еквівалентне правому |
| ![](/media/right-join-vis.png)              | **RIGHT JOIN**                       | Праве з'єднання                            |
| ![](/media/right-without-left-join-vis.png) | **RIGHT JOIN ⊄ LEFT**                | Праве з'єднання, що не еквівалентне лівому |
| ![](/media/full-outer-join-vis.png)         | **FULL [OUTER] JOIN**                | Повне зовнішнє з'єднання                   |
| ![](/media/intersection-join-vis.png)       | **FULL [OUTER] JOIN ⊄ INTERSECTION** | Повне зовнішнє з'єднання, не перетин       |

::: info
1. **GROUP BY** застосовується до неагрегованих (за допомогою функцій) колонок у **SELECT**.  
2. Для фільтрації після **GROUP BY** використовується **HAVING**.
:::

## Рівні ізоляції в SQL базах даних

| Рівень ізоляції      | Аномалія               | Опис                                                                                                              |
|----------------------|------------------------|-------------------------------------------------------------------------------------------------------------------|
| **Read Uncommitted** | Lost Update            | Виникає, коли дві транзакції читають одну й ту ж строку, потім одна з них оновлює рядок, а інша – ні.              |
| **Read Committed**   | Dirty Read             | Транзакція читає незавершені зміни іншої транзакції. *(За замовчуванням у PostgreSQL)*                               |
| **Repeatable Read**  | Non-repeatable Read    | Повторне читання одного рядка, який був змінений іншою транзакцією між зверненнями.                                  |
| **Serializable**     | Phantom Read           | Запит, виконаний двічі, дає різні результати через додавання/видалення рядків іншою транзакцією.                     |
|                      | Serialization Anomaly  | Успішне виконання транзакцій не узгоджується з можливим порядком їх послідовного виконання при одночасному запуску.    |

*Значення та доступність рівнів можуть залежати від конкретної СКБД.*

## SQL Locks

1. **Shared Lock** – блокування для запису, але дозволяється зчитування.
2. **Exclusive Lock** – блокування для як зчитування, так і для запису.

**Додатково:**
- **Optimistic Lock** – версіонування рядків із перевіркою при коміті (реалізується на рівні додатку).
- **Pessimistic Lock** – ресурс блокується одразу (на рівні рядків, сторінок або таблиць) для запобігання дедлоків.

*Приклад використання:*

```sql
-- SELECT FOR UPDATE для блокування рядка
SELECT * FROM accounts WHERE id = 1 FOR SHARE;

BEGIN;
SELECT txid_current(), pg_backend_pid();
-- Приклад виводу:
-- txid_current | pg_backend_pid
-- 143010       | 31675

UPDATE accounts SET amount = amount + 100.00 WHERE id = 1;
```

Команда з `NOWAIT` поверне помилку, якщо ресурс заблоковано:

```sql
SELECT * FROM accounts FOR UPDATE NOWAIT;
-- ERROR: could not obtain lock on row in relation "accounts"
```

Або можна пропустити заблоковані рядки за допомогою `SKIP LOCKED`:

```sql
SELECT * FROM accounts ORDER BY id FOR UPDATE SKIP LOCKED LIMIT 1;
```
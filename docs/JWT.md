# JWT (JSON Web Tokens)

## Основи: Структура JWT

Токен складається з 3 частин, розділених крапками (`.`), кожна закодована в **Base64Url**: `Заголовок.Корисне_Навантаження.Підпис`

Приклад: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIn0.R5V2yF0-hfyefh7Gai3ntxzXTF9T0yVT5WWjRBwV_0c`

### 1. Заголовок (Header)

**Призначення:** Містить метадані про токен, зокрема тип токена (`typ`) та алгоритм підпису (`alg`), що використовується для створення підпису.

**Формат:** JSON об'єкт.
```json5
{
  "alg": "HS256", // Алгоритм: HMAC з SHA-256
  "typ": "JWT"
}
```

### 2. Корисне Навантаження (Payload)

**Призначення:** Містить "твердження" (claims) – інформацію про суб'єкта та інші дані.
**Формат:** JSON об'єкт.
```json5
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
}
```

### 3. Підпис (Signature)

**Призначення:** перевірка цілісності повідомлення (що Заголовок та Payload не були змінені) та, у випадку асиметричних алгоритмів, для автентифікації відправника.
**Формування:** створюється шляхом застосування алгоритму підпису (`alg` з Заголовка) до конкатенації закодованого Заголовка, крапки (`.`) та закодованого Корисного Навантаження, використовуючи секретний ключ (для HMAC) або приватний ключ (для RSA/ECDSA).

## Процес Генерації JWT

Створення JWT включає наступні кроки:

1.  **Визначити Заголовок:** Створити JSON об'єкт Заголовка, вказавши алгоритм підпису (`alg`, напр., `HS256`, `RS256`) та тип (`typ: "JWT"`).
2.  **Визначити Payload:** Створити JSON об'єкт Корисного Навантаження з необхідними твердженнями (claims).
3.  **Закодувати Заголовок:** Перетворити JSON Заголовка в рядок Base64Url.
4.  **Закодувати Payload:** Перетворити JSON Корисного Навантаження в рядок Base64Url.
5.  **Сформувати дані для підпису:** Об'єднати закодований Заголовок, крапку (`.`) та закодований Payload. Наприклад: `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIn0`
6.  **Створити Підпис:**
    *   Взяти дані для підпису (з кроку 5).
    *   Взяти секретний ключ (для HMAC алгоритмів, наприклад `HS256`) або приватний ключ (для RSA/ECDSA алгоритмів, наприклад `RS256`).
    *   Застосувати алгоритм підпису, вказаний у Заголовку (`alg`), до даних та ключа.
        *   Приклад для `HS256`: `HMACSHA256(dani_dlia_pidpysu, secret_key)`
        *   Приклад для `RS256`: `RSASSA-PKCS1-v1_5-SIGN(private_key, SHA256(dani_dlia_pidpysu))`
7.  **Закодувати Підпис:** Перетворити отриманий бінарний підпис в рядок Base64Url.
8.  **Зібрати Токен:** Об'єднати закодований Заголовок (крок 3), крапку (`.`), закодований Payload (крок 4), крапку (`.`) та закодований Підпис (крок 7).

## Процес Перевірки (Валідації) JWT

Коли сервер отримує JWT, він повинен перевірити його автентичність та цілісність:

1.  **Розділити Токен:** Розбити отриманий рядок JWT на три частини, використовуючи крапку (`.`) як роздільник. Отримаємо: `encodedHeader`, `encodedPayload`, `encodedSignature`.
2.  **Декодувати Заголовок:** Виконати Base64Url декодування `encodedHeader`, щоб отримати JSON Заголовка. Визначити алгоритм (`alg`), вказаний у заголовку.
    ::: danger Важливо
    Сервер **повинен** перевірити, чи отриманий `alg` є тим алгоритмом, який він очікує та підтримує. Ніколи сліпо не довіряйте значенню `alg` з токена! Наприклад, не дозволяйте використання `alg: none`, якщо ваш застосунок вимагає підписані токени.
    :::
3.  **Декодувати Payload:** Виконати Base64Url декодування `encodedPayload`, щоб отримати JSON Корисного Навантаження.
4.  **Перерахувати Підпис:**
    *   Взяти *оригінальні* закодовані дані з токена: `encodedHeader` (з кроку 1) та `encodedPayload` (з кроку 1).
    *   Об'єднати їх через крапку: `encodedHeader + "." + encodedPayload`.
    *   Взяти *той самий* секретний ключ (для HMAC) або *відповідний публічний ключ* (для RSA/ECDSA), який використовувався для генерації токена.
    *   Застосувати *той самий* алгоритм підпису (`alg` з декодованого Заголовка) до об'єднаних даних та ключа.
    *   Закодувати результат (перерахований бінарний підпис) у формат Base64Url. Назвемо це `recalculatedEncodedSignature`.
5.  **Порівняти Підписи:** Порівняти `recalculatedEncodedSignature` (з кроку 4) з `encodedSignature` (третя частина оригінального токена з кроку 1).
    *   **Якщо підписи збігаються:** Токен є автентичним (виданий довіреним джерелом, що має ключ) та цілісним (Заголовок і Payload не були змінені після підпису).
    *   **Якщо підписи НЕ збігаються:** Токен невалідний (можливо, підроблений, змінений, або використано невірний ключ для перевірки). Такий токен слід відхилити.
6.  **Перевірити Твердження (Claims):** Якщо підпис валідний, сервер *повинен* перевірити твердження в декодованому Payload (з кроку 3), такі як:
    *   `exp`: Чи не закінчився термін дії токена?
    *   `nbf`: Чи вже настав час, з якого токен є дійсним?
    *   `iss`: Чи виданий токен очікуваним видавцем?
    *   `aud`: Чи призначений токен для цього сервера/сервісу (аудиторії)?
    *   Та інші специфічні для застосунку твердження.

## Ключові Концепції

*   **Base64Url Encoding:** Спеціальний варіант Base64, безпечний для використання в URL (символи `+` замінюються на `-`, `/` на `_`, а доповнення `=` видаляється). Це метод *кодування*, а не шифрування.
*   **HMAC (напр., HS256):** Симетричний алгоритм. Один і той самий секретний ключ використовується і для генерації, і для перевірки підпису. Ключ повинен бути відомий тільки серверу(ам).
*   **RSA/ECDSA (напр., RS256, ES256):** Асиметричні алгоритми. Приватний ключ використовується для генерації підпису (зберігається в секреті на сервері, що видає токен), а відповідний публічний ключ використовується для перевірки підпису (може бути розповсюджений серед серверів, що перевіряють токен).

## Симетричні vs Асиметричні Алгоритми в JWT

Вибір між симетричними (HMAC) та асиметричними (RSA/ECDSA) алгоритмами підпису для JWT залежить від архітектури системи:

::: details Симетричні (HMAC)
*   **Принцип:** Використовується єдиний секретний ключ, який відомий і серверу, що генерує токен (Authorization Server), і серверу(ам), що перевіряє(ють) токен (Resource Server).
*   **Переваги:**
    *   Швидше обчислюються порівняно з асиметричними.
*   **Недоліки:**
    *   Секретний ключ повинен бути надійно переданий та збережений на всіх серверах, які перевіряють токен. Якщо ключ скомпрометовано на будь-якому сервері, зловмисник зможе не тільки перевіряти, а й **генерувати** валідні токени.
*   **Сценарії використання:**
    *   Прості системи, де сервер, що видає токени, і сервер, що їх перевіряє, є одним і тим же сервером.
    *   Системи, де невелика кількість серверів тісно пов'язані, і безпечна передача спільного секрету не є проблемою.
:::

::: details Асиметричні (RSA/ECDSA)
*   **Принцип:** Сервер, що генерує токен, використовує свій **приватний ключ** для підпису. Сервери, що перевіряють токен, використовують відповідний **публічний ключ**. Публічний ключ не дозволяє генерувати нові підписи.
*   **Переваги:**
    *   **Більша безпека в розподілених системах:** Приватний ключ зберігається тільки на сервері, що видає токени. Ресурсні сервери потребують лише публічного ключа, який може бути вільно розповсюджений (наприклад, через JWK Set endpoint). Компрометація публічного ключа не дозволить зловмиснику генерувати нові токени.
    *   **Розв'язка обов'язків:** Чіткий поділ між тим, хто видає токен, і тим, хто його перевіряє.
*   **Недоліки:**
    *   Обчислення (як генерація, так і перевірка) зазвичай повільніші, ніж у HMAC.
*   **Сценарії використання:**
    *   Мікросервісна архітектура, де багато різних сервісів повинні мати можливість перевіряти токени, видані центральним сервером автентифікації.
    *   Системи, де токени перевіряються третіми сторонами, яким не можна довіряти приватний ключ.
:::

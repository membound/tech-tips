# Шлях запита до бекенда

## 1. Ініціація Запиту

* Користувач вводить URL (наприклад, `https://google.com`) в адресний рядок браузера і натискає клавішу `Enter`.
* Або JavaScript код ініціює мережевий запит (наприклад, через `fetch` або `XMLHttpRequest`).

## 2. Парсинг URL

Браузер розбирає URL на: протокол (`https`), хост (`google.com`), шлях (`/`, якщо не вказано) та інші параметри.

## 3. Перевірка кешу браузера та HSTS

Браузер перевіряє:
* чи є адреса запитуваного домена локальному кеші;
* список HSTS (HTTP Strict Transport Security), для визначення чи обовз'язковий HTTPS для цього домену.

## 4. DNS Запит (Пошук IP-адреси)

Якщо IP-адреса для домену (`google.com`) не знайдена в кеші (браузера, ОС, роутера), браузер надсилає DNS-запит до DNS-резолвера, щоб перетворити ім'я хоста на відповідну IP-адресу сервера (наприклад, `10.10.10.10`).

## 5. Встановлення TCP З'єднання

Браузер встановлює TCP-з'єднання з сервером за отриманою IP-адресою. Це відбувається за допомогою триетапного "рукостискання" (SYN, SYN-ACK, ACK).

::: tip Мета триетапного рукостискання
Головна мета — переконатися, що обидві сторони існують, готові до зв'язку, та узгодити початкові номери послідовності (Sequence Numbers) для надійної передачі даних.
:::

*   **Крок 1 (SYN):** Клієнт надсилає пакет, вказуючи свій початковий номер послідовності.
*   **Крок 2 (SYN-ACK):** Сервер відповідає підтверджуючи отримання SYN клієнта (ACK) і надсилаючи свій власний SYN зі своїм початковим номером послідовності.
*   **Крок 3 (ACK):** Клієнт надсилає пакет ACK, підтверджуючи отримання SYN-ACK від сервера. **Цей крок критично важливий, оскільки він повідомляє серверу, що клієнт отримав підтвердження і обидві сторони готові до обміну даними.**

::: details Що відбувається при втраті пакетів під час рукостискання?
**Якщо SYN-ACK або ACK втрачено:** Клієнт/сервер не отримає відповіді на свій SYN/SYN-ACK. Після певного тайм-ауту він повторно надішле пакет SYN/SYN-ACK.
Клієнт, отримавши дублікат SYN-ACK, просто надішле ще один ACK.
:::

::: warning Потенційні проблеми
Хоча механізми повторної передачі забезпечують надійність, сценарій, коли сервер очікує на фінальний ACK (Крок 3), може використовуватися в атаках типу SYN Flood, де зловмисник надсилає багато SYN-пакетів, змушуючи сервер виділяти ресурси для напіввідкритих з'єднань, які ніколи не завершуються. Сучасні системи мають засоби протидії цьому.
:::

## 7. TLS/SSL Рукостискання (для HTTPS)

Якщо використовується протокол `https`, відбувається TLS/SSL рукостискання поверх TCP-з'єднання.

**Використовуються:**
*   асиметричні алгоритми (наприклад, RSA, ECDH) для безпечного обміну ключами та автентифікації сервера (перевірка сертифіката);
*   симетричні алгоритми (наприклад, AES) для швидкого шифрування самих даних;
*   хеш-функції/MAC (наприклад, SHA-256) для перевірки цілісності даних.

Разом вони забезпечують конфіденційність (ніхто не може прочитати), цілісність (ніхто не може змінити непомітно) та автентифікацію (ви спілкуєтеся з правильним сервером).

```mermaid
sequenceDiagram
participant C as Client (Browser)
participant S as Server

Note over C,S: Початок TLS/SSL Рукостискання

C->>S: ClientHello (Версія TLS, Шифри, ClientRandom)
S->>C: ServerHello (Обраний Шифр, Версія TLS, ServerRandom, Сертифікат[ПублічнийКлючСервера])

Note over C: Перевірка Сертифікату Сервера
C->>C: Генерація Pre-Master Secret
C->>S: ClientKeyExchange (Зашифрований Pre-Master Secret з ПублічнимКлючемСервера)

Note over S: Розшифровка Pre-Master Secret за допомогою ПриватногоКлючаСервера
S->>S: Генерація Сесійних Ключів <br/>(вик. ClientRandom, ServerRandom, Pre-Master Secret)
C->>C: Генерація Сесійних Ключів <br/>(вик. ClientRandom, ServerRandom, Pre-Master Secret)

Note over C,S: Обидві сторони тепер мають однаковий Симетричний Сесійний Ключ

C->>S: ChangeCipherSpec
C->>S: Finished (Зашифровано Сесійним Ключем)

S->>C: ChangeCipherSpec
S->>C: Finished (Зашифровано Сесійним Ключем)

Note over C,S: Рукостискання завершено - Встановлено Безпечний Канал

C->>S: Зашифровані Дані (напр., HTTP Запит) з Сесійним Ключем
S->>C: Зашифровані Дані (напр., HTTP Відповідь) з Сесійним Ключем
```
**Пояснення діаграми:**
*   Клієнт та сервер обмінюються інформацією про підтримувані методи шифрування та випадковими даними.
*   Сервер надсилає свій сертифікат, що містить публічний ключ.
*   Клієнт перевіряє сертифікат, генерує секрет (`Pre-Master Secret`) і шифрує його публічним ключем сервера, надсилаючи результат серверу.
*   Тільки сервер може розшифрувати цей секрет своїм приватним ключем.
*   Використовуючи обміняні випадкові дані та `Pre-Master Secret`, обидві сторони незалежно генерують *однаковий* симетричний сесійний ключ (наприклад, AES ключ).
*   Після підтвердження успішного рукостискання (повідомлення `Finished`), весь подальший обмін даними шифрується цим швидким симетричним ключем.

## 8. Надсилання HTTP(S) Запиту

Браузер формує та надсилає HTTP(S) запит до сервера через встановлене **(тепер зашифроване)** з'єднання. Запит містить метод (`GET`, `POST` тощо), шлях до ресурсу, версію протоколу, заголовки та, можливо, тіло запиту.

**Браузер додає різні HTTP-заголовки, такі як:**
*   `Host`: ім'я сервера;
*   `User-Agent`: інформація про браузер;
*   `Accept`: підтримувані типи контенту;
*   `Accept-Language`: бажані мови;
*   `Accept-Encoding`: підтримувані методи стиснення;
*   `Cookie`: раніше встановлені сервером кукі.

**Якщо запит ініційовано скриптом:**
*   **CORS Preflight:** браузер автоматично надсилає попередній запит з методом `OPTIONS` (preflight request). Цей запит перевіряє у сервера, чи дозволено виконувати основний запит з поточного домену з вказаними методом та заголовками.
*   **Заголовки `Origin` та `Referer`:** Браузер може додати заголовок `Origin` (вказує домен, з якого йде запит) для cross-origin запитів та `Referer` (URL сторінки, що ініціювала запит).

::: details Приклад GET
```http
GET /search?q=something HTTP/1.1
Host: google.com
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Referer: https://google.com/previous-page
Accept-Encoding: gzip, deflate, br
Accept-Language: uk-UA,uk;q=0.9,en-US;q=0.8,en;q=0.7
Cookie: session_id=a1b2c3d4e5f6; user_preference=dark_mode; tracking_consent=accepted
```
:::

## 9. Обробка Запиту Сервером

Веб-сервер отримує **(і розшифровує, якщо HTTPS)** запит (спочатку `OPTIONS`, якщо був preflight, а потім основний), обробляє його (перевіряє CORS-заголовки у відповіді на `OPTIONS`, передає на обробку серверному застосунку, звертається до бази даних) та готує відповідь.

## 10. Надсилання HTTP(S) Відповіді

Сервер надсилає **(і шифрує, якщо HTTPS)** HTTP(S) відповідь назад браузеру. Відповідь містить статус-код (наприклад, `200 OK`, `204 No Content` для успішного preflight), заголовки (включаючи CORS-заголовки як `Access-Control-Allow-Origin` у відповідь на preflight або основний запит) та тіло відповіді (HTML, JSON, XML, зображення тощо).

## 11. Обробка Відповіді Браузером

Браузер отримує **(і розшифровує, якщо HTTPS)** відповідь від сервера.
*   **Якщо запит був навігаційним (введення URL):** Браузер починає парсинг HTML-коду відповіді.
*   **Якщо запит ініційовано скриптом (`fetch`/`XHR`):**
*   **CORS Перевірка:** Браузер перевіряє наявність та коректність CORS-заголовків (наприклад, `Access-Control-Allow-Origin`) у відповіді, якщо запит був cross-origin. Якщо політика CORS не дозволяє доступ, браузер блокує доступ скрипта до відповіді, генеруючи помилку.
*   **Передача даних скрипту:** Якщо все гаразд, дані відповіді (тіло, статус, заголовки) передаються у відповідний JavaScript код (наприклад, у `.then()` для `fetch` або в обробник подій для `XMLHttpRequest`) для подальшої обробки.

## 12. Завантаження Додаткових Ресурсів

*   **При навігації:** Під час парсингу HTML браузер знаходить посилання на інші ресурси (CSS, JS, зображення) і ініціює їх завантаження (повторюючи кроки 4-9, включаючи TLS рукостискання для ресурсів з HTTPS-доменів).
*   **При обробці скриптом:** JavaScript може програмно додати елементи на сторінку (наприклад, `<img>`), що також ініціює завантаження відповідних ресурсів.

## 13. Вібораження

*   **При навігації:** Браузер будує DOM та CSSOM, створює Render Tree, розраховує Layout та виконує Paint для відображення сторінки.
*   **При обробці скриптом:** JavaScript, отримавши дані, маніпулює існуючим DOM (додає/видаляє/змінює елементи), що може викликати частковий або повний Reflow/Repaint для оновлення видимої частини сторінки без повного перезавантаження.

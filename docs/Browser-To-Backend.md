# Що відбувається, коли ви вводите URL в браузері?

Ця сторінка описує послідовність дій, які виконуються "під капотом", коли ви вводите адресу веб-сайту (URL) в адресний рядок браузера та натискаєте Enter, **а також коли запит ініціюється JavaScript кодом на сторінці.**

## Покроковий процес:

1.  **Ініціація Запиту**
    Користувач вводить URL (наприклад, `https://vitepress.dev`) в адресний рядок браузера і натискає клавішу `Enter`. **Або ж, дія на сторінці (клік, скрол тощо) викликає виконання JavaScript коду, який ініціює мережевий запит (наприклад, через `fetch` або `XMLHttpRequest`).**

2.  **Парсинг URL**
    Браузер розбирає URL запитуваного ресурсу на складові частини: протокол (`https`), хост (`vitepress.dev`), шлях (`/`, якщо не вказано) та інші параметри.

3.  **Перевірка кешу браузера та HSTS**
    Браузер перевіряє, чи є копія запитуваного ресурсу у його локальному кеші. Також перевіряється список HSTS (HTTP Strict Transport Security), щоб визначити, чи потрібно примусово використовувати HTTPS для цього домену.

4.  **DNS Запит (Пошук IP-адреси)**
    Якщо IP-адреса для домену (`vitepress.dev`) не знайдена в кеші (браузера, ОС, роутера), браузер надсилає DNS-запит до DNS-резолвера, щоб перетворити ім'я хоста на відповідну IP-адресу сервера (наприклад, `104.18.12.199`).

5.  **Встановлення TCP З'єднання**
    Браузер встановлює TCP-з'єднання з сервером за отриманою IP-адресою. Це відбувається за допомогою триетапного "рукостискання" (SYN, SYN-ACK, ACK).

    ::: tip Мета триетапного рукостискання
    Головна мета — переконатися, що обидві сторони існують, готові до зв'язку, та узгодити початкові номери послідовності (Sequence Numbers) для надійної передачі даних.
    :::

    *   **Крок 1 (SYN):** Клієнт надсилає пакет, вказуючи свій початковий номер послідовності.
    *   **Крок 2 (SYN-ACK):** Сервер відповідає підтверджуючи отримання SYN клієнта (ACK) і надсилаючи свій власний SYN зі своїм початковим номером послідовності.
    *   **Крок 3 (ACK):** Клієнт надсилає пакет ACK, підтверджуючи отримання SYN-ACK від сервера. **Цей крок критично важливий, оскільки він повідомляє серверу, що клієнт отримав підтвердження і обидві сторони готові до обміну даними.**

    ::: details Що відбувається при втраті пакетів під час рукостискання?
    **Якщо SYN-ACK або ACK втрачено:** Клієнт/сервер не отримає відповіді на свій SYN/SYN-ACK. Після певного тайм-ауту він повторно надішле пакет SYN/SYN-ACK.
    Клієнт, отримавши дублікат SYN-ACK, просто надішле ще один ACK.
    :::

    ::: warning Потенційні проблеми
    Хоча механізми повторної передачі забезпечують надійність, сценарій, коли сервер очікує на фінальний ACK (Крок 3), може використовуватися в атаках типу SYN Flood, де зловмисник надсилає багато SYN-пакетів, змушуючи сервер виділяти ресурси для напіввідкритих з'єднань, які ніколи не завершуються. Сучасні системи мають засоби протидії цьому.
    :::

7.  **TLS/SSL Рукостискання (для HTTPS)**
    Якщо використовується протокол `https`, відбувається TLS/SSL рукостискання поверх TCP-з'єднання.

    **Використовуються:**
    *   асиметричні алгоритми (наприклад, RSA, ECDH) для безпечного обміну ключами та автентифікації сервера (перевірка сертифіката);
    *   симетричні алгоритми (наприклад, AES) для швидкого шифрування самих даних;
    *   хеш-функції/MAC (наприклад, SHA-256) для перевірки цілісності даних.

    Разом вони забезпечують конфіденційність (ніхто не може прочитати), цілісність (ніхто не може змінити непомітно) та автентифікацію (ви спілкуєтеся з правильним сервером).

    ```mermaid
    sequenceDiagram
        participant C as Client (Browser)
        participant S as Server

        Note over C,S: Початок TLS/SSL Рукостискання

        C->>S: ClientHello (Версія TLS, Шифри, ClientRandom)
        S->>C: ServerHello (Обраний Шифр, Версія TLS, ServerRandom, Сертифікат[ПублічнийКлючСервера])

        Note over C: Перевірка Сертифікату Сервера
        C->>C: Генерація Pre-Master Secret
        C->>S: ClientKeyExchange (Зашифрований Pre-Master Secret з ПублічнимКлючемСервера)

        Note over S: Розшифровка Pre-Master Secret за допомогою ПриватногоКлючаСервера
        S->>S: Генерація Сесійних Ключів <br/>(вик. ClientRandom, ServerRandom, Pre-Master Secret)
        C->>C: Генерація Сесійних Ключів <br/>(вик. ClientRandom, ServerRandom, Pre-Master Secret)

        Note over C,S: Обидві сторони тепер мають однаковий Симетричний Сесійний Ключ

        C->>S: ChangeCipherSpec
        C->>S: Finished (Зашифровано Сесійним Ключем)

        S->>C: ChangeCipherSpec
        S->>C: Finished (Зашифровано Сесійним Ключем)

        Note over C,S: Рукостискання завершено - Встановлено Безпечний Канал

        C->>S: Зашифровані Дані (напр., HTTP Запит) з Сесійним Ключем
        S->>C: Зашифровані Дані (напр., HTTP Відповідь) з Сесійним Ключем
    ```
    **Пояснення діаграми:**
    *   Клієнт та сервер обмінюються інформацією про підтримувані методи шифрування та випадковими даними.
    *   Сервер надсилає свій сертифікат, що містить публічний ключ.
    *   Клієнт перевіряє сертифікат, генерує секрет (`Pre-Master Secret`) і шифрує його публічним ключем сервера, надсилаючи результат серверу.
    *   Тільки сервер може розшифрувати цей секрет своїм приватним ключем.
    *   Використовуючи обміняні випадкові дані та `Pre-Master Secret`, обидві сторони незалежно генерують *однаковий* симетричний сесійний ключ (наприклад, AES ключ).
    *   Після підтвердження успішного рукостискання (повідомлення `Finished`), весь подальший обмін даними шифрується цим швидким симетричним ключем.

8.  **Надсилання HTTP(S) Запиту**
    Браузер формує та надсилає HTTP(S) запит до сервера через встановлене **(тепер зашифроване)** з'єднання. Запит містить метод (`GET`, `POST` тощо), шлях до ресурсу, версію протоколу, заголовки та, можливо, тіло запиту.

    **Браузер додає різні HTTP-заголовки, такі як: **
    *   `Host`: ім'я сервера;
    *   `User-Agent`: інформація про браузер;
    *   `Accept`: підтримувані типи контенту;
    *   `Accept-Language`: бажані мови;
    *   `Accept-Encoding`: підтримувані методи стиснення;
    *   `Cookie`: раніше встановлені сервером кукі.

    *   **Якщо запит ініційовано скриптом:**
        *   **CORS Preflight:** Якщо запит є "не простим" (наприклад, використовує методи окрім GET/POST/HEAD, має кастомні заголовки) і надсилається на інший домен (Cross-Origin), браузер автоматично надсилає попередній запит з методом `OPTIONS` (preflight request). Цей запит перевіряє у сервера, чи дозволено виконувати основний запит з поточного домену з вказаними методом та заголовками.
        *   **Заголовки `Origin` та `Referer`:** Браузер може додати заголовок `Origin` (вказує домен, з якого йде запит) для cross-origin запитів та `Referer` (URL сторінки, що ініціювала запит).

9.  **Обробка Запиту Сервером**
    Веб-сервер отримує **(і розшифровує, якщо HTTPS)** запит (спочатку `OPTIONS`, якщо був preflight, а потім основний), обробляє його (перевіряє CORS-заголовки у відповіді на `OPTIONS`, передає на обробку серверному застосунку, звертається до бази даних) та готує відповідь.

10.  **Надсилання HTTP(S) Відповіді**
    Сервер надсилає **(і шифрує, якщо HTTPS)** HTTP(S) відповідь назад браузеру. Відповідь містить статус-код (наприклад, `200 OK`, `204 No Content` для успішного preflight), заголовки (включаючи CORS-заголовки як `Access-Control-Allow-Origin` у відповідь на preflight або основний запит) та тіло відповіді (HTML, JSON, XML, зображення тощо).

11. **Обробка Відповіді Браузером**
    Браузер отримує **(і розшифровує, якщо HTTPS)** відповідь від сервера.
    *   **Якщо запит був навігаційним (введення URL):** Браузер починає парсинг HTML-коду відповіді.
    *   **Якщо запит ініційовано скриптом (`fetch`/`XHR`):**
        *   **CORS Перевірка:** Браузер перевіряє наявність та коректність CORS-заголовків (наприклад, `Access-Control-Allow-Origin`) у відповіді, якщо запит був cross-origin. Якщо політика CORS не дозволяє доступ, браузер блокує доступ скрипта до відповіді, генеруючи помилку.
        *   **Передача даних скрипту:** Якщо все гаразд, дані відповіді (тіло, статус, заголовки) передаються у відповідний JavaScript код (наприклад, у `.then()` для `fetch` або в обробник подій для `XMLHttpRequest`) для подальшої обробки.

12. **Завантаження Додаткових Ресурсів**
    *   **При навігації:** Під час парсингу HTML браузер знаходить посилання на інші ресурси (CSS, JS, зображення) і ініціює їх завантаження (повторюючи кроки 4-9, включаючи TLS рукостискання для ресурсів з HTTPS-доменів).
    *   **При обробці скриптом:** JavaScript може програмно додати елементи на сторінку (наприклад, `<img>`), що також ініціює завантаження відповідних ресурсів.

13. **Рендеринг Сторінки / Оновлення Інтерфейсу**
    *   **При навігації:** Браузер будує DOM та CSSOM, створює Render Tree, розраховує Layout та виконує Paint для відображення сторінки.
    *   **При обробці скриптом:** JavaScript, отримавши дані, маніпулює існуючим DOM (додає/видаляє/змінює елементи), що може викликати частковий або повний Reflow/Repaint для оновлення видимої частини сторінки без повного перезавантаження.

14. **Відображення/Оновлення Сторінки**
    Користувач бачить повністю завантажену сторінку (при навігації) або оновлення на поточній сторінці (як результат роботи скрипта). Фонова активність (асинхронні запити, виконання JS) може продовжуватися.
